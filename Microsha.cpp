#include <unistd.h>
#include <stdio.h>
#include <dirent.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <stdlib.h>
#include <iostream>
#include <vector>
#include <string>
#include <time.h>
#include <cstring>
#include <sys/dir.h>
#include <fcntl.h>
#include <dirent.h>
#include <map>
#include <sys/resource.h>
#include <sys/time.h>
#include <regex>
using namespace std;
//COLORS:
#define GREEN_BOLD   "\x1b[1;32m"
#define COLOR_RESET   "\x1b[0m"

//DEBUG:
//#define ROOT_DEBUG
//#define PRINT_ENV
//#define ENV_F_DEBUG
//#define PRINT_WORDS
//#define PROCESS_DEBUG
//#define PIPE_DEBUG
//#define START_DIR_DEBUG

//RUN
#define RUN_PROCESSES

map<string, void (*)(string*, int)> Microsha_functions;

void greeting(bool sudoflag){
    char dir[4096]; getcwd(dir, 4096);
    sudoflag?printf(GREEN_BOLD "%s!" COLOR_RESET, dir):printf(GREEN_BOLD "%s>" COLOR_RESET, dir);
}
void get_string(string &s){
    for(char c = getchar();!feof(stdin) && c!='\n';s.push_back(c), c = getchar());
}


/*for(int i=0; i<256; ++i){
    if (i>='a' && i<='z' || i>='A' && i<='Z' || i>='0' && i<='9' || i=='_')
        cout<<"1, ";
    else cout<<"0, ";
}*/
const int ENV_NAME[256] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,//generated by code above
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
void env_f(string& s){
    #ifdef ENV_F_DEBUG
    cout<<"env_f string: "<<s<<'\n';
    #endif
    bool f = false;
    for(int i=0; i<s.size(); ++i){
        if (s[i]=='\"'){f = !f; continue;}
        if (f) continue;
        if(s[i]=='$'){
            int save = i; ++i;
            string w;
            bool t=false;
            if(s[i]=='('){ ++i; t=true;}
            for (; i<s.size() && ENV_NAME[s[i]]==1; ++i)
                w.push_back(s[i]);
            w.push_back(0);
            char symbol = 0, *p = getenv(&w[0]); 
            if (p==NULL) p=&symbol;
            if (t) ++i;
            s.erase(save, i-save);
            const int len=strlen(p);
            s.insert(save, p); i = save+len-1;
        }
    }
}
void start_directory(string& dir_name, vector<regex>& h,  vector<string>& h1, vector<bool>& flags, vector<string>& slash, vector<string>& t, int k){
    DIR *dir = dir_name.empty() ? opendir("./") : opendir(dir_name.c_str());
    if (dir == NULL) {
        //perror("!!!opendir");
        return;
    }
    if(k==h.size()){closedir(dir); dir_name.push_back(0); t.push_back(dir_name); return;}
    for (auto rd = readdir(dir); rd != NULL; rd = readdir(dir)) {
        //printf("!!!!%s#\n", rd->d_name);
        if (slash[k].empty() && rd->d_type == DT_REG && k==h.size()-1 && regex_match(rd->d_name, h[k])){
            string new_dir_name(dir_name + string(rd->d_name));
            new_dir_name.push_back(0);
            t.push_back(new_dir_name);
            #ifdef START_DIR_DEBUG
            printf("!!!  %s :  %s\n", dir_name.c_str(), rd->d_name);
            printf("##%s##\n", new_dir_name.c_str());
            #endif
        }
        else if (rd->d_type == DT_DIR && (strcmp(rd->d_name, ".") != 0 && strcmp(rd->d_name, "..") != 0 || flags[k] && strcmp(rd->d_name, &h1[k][0]) == 0) && regex_match(rd->d_name, h[k])){
            int m=k+1;
            string new_dir_name(dir_name + string(rd->d_name) + slash[k]);
            for(int n = h.size()-1; m<n && flags[m]; ++m)
                new_dir_name += h1[m] + slash[m];
            #ifdef START_DIR_DEBUG
            printf("!!!%s :\n", new_dir_name.c_str());
            #endif
            if (k==h.size()-1) {start_directory(new_dir_name, h, h1, flags, slash, t, k+1);}
            else start_directory(new_dir_name, h, h1, flags, slash, t, m);
        }
    }
    closedir(dir);
    return;
}
void expand_links(string& w, vector<string>& t){//expand \* and \? anf \+
    int i=0;
    string dir;
    for(; w[i]!=0 && w[i]!='*' && w[i]!='+' && w[i]!='?'; ++i) dir.push_back(w[i]);
    if(w[i]==0){ t.push_back(w); return;}
    dir.push_back(0);
    for(; i>=0 && w[i]!='/'; --i) dir.pop_back();
    ++i;
    vector<regex> h;
    vector<string> slash, h1;
    vector<bool> flags;
    string p, l;
    bool fl = true;
    for (; w[i]!=0; ++i){
        if (w[i]=='/'){
            h.push_back(regex(p.c_str())); h1.push_back(l); l.clear(); flags.push_back(fl); fl = true; p.clear();
            for(;w[i]=='/';++i) p.push_back('/'); slash.push_back(p); p.clear();
            if (w[i]==0) break; --i;
            continue;
        }
        switch (w[i]){
        case '.': p.push_back('\\'); p.push_back('.'); break;
        case '*': p.push_back('.'); p.push_back('*'); fl = false; break;
        case '+': p.push_back('.'); p.push_back('+'); fl = false; break;
        case '?': p.push_back('.'); p.push_back('?'); fl = false; break;
        case '\\': p.push_back('\\'); p.push_back('\\'); break;
        default: p.push_back(w[i]); break;
        }
        l.push_back(w[i]);
    }
    if (!p.empty()){
        h.push_back(regex(p.c_str())); h1.push_back(l); l.clear(); flags.push_back(fl); p.clear();
        slash.push_back(p); p.clear();
    }
    #ifdef START_DIR_DEBUG
    printf("dir #%s#\n", &dir[0]);
    for (int i=0; i<h1.size(); ++i) printf("%d)#%s# #%s# %s\n", i, h1[i].c_str(), slash[i].c_str(), flags[i]?"flags_true":"flags_false");
    #endif
    int save_size = t.size();
    start_directory(dir, h, h1, flags, slash, t, 0);
    if (t.size() == save_size) t.push_back(w);
}
void string_to_words1(string& s, vector<string>& t){
    s.push_back(0);
    bool f=false;
    string w;
    for(int i=0; s[i]!=0; ++i){
        if (s[i]=='\"'){
            f = !f;
            w.push_back(s[i]);
            continue;
        }
        if (f) {w.push_back(s[i]); continue;}
        if (s[i]=='\t' || s[i]==' ' || s[i]=='\n'){
            if (!w.empty()) {w.push_back(0); expand_links(w, t);}
            w.clear();
            continue;
        }
        w.push_back(s[i]);
    }
    if (!w.empty()) {w.push_back(0); expand_links(w, t);}
}
int parce(vector<string>& t, vector<vector<string>>& v,string& input_filename, string& output_filename,
 bool& input_flag, bool& output_flag, bool& time_flag){
    int j=0, i=0; time_flag = input_flag = output_flag = false;
    if (!t.empty() && !t[0].empty() && strcmp(&t[0][0], "time") == 0) {++i; time_flag = true;}
    vector<string> p; v.push_back(p);
    bool conveyer_flag=false;
    for (int n=t.size(); i<n; ++i){
        if (strcmp(&t[i][0], "|") == 0) {
            if (output_flag) return -1;
            ++j; v.push_back(p); conveyer_flag = true; continue;
        }
        if (strcmp(&t[i][0], ">") == 0) {
            if (!output_flag && i!=n-1){
                ++i;
                output_filename = t[i];
                output_flag = true;
                continue;
            } return -1;
        }
        if (strcmp(&t[i][0], "<") == 0) {
            if (!conveyer_flag && !output_flag && !input_flag && i!=n-1){
                ++i;
                input_filename = t[i];
                input_flag = true;
                continue;
            } return -1;
        }
        v[j].push_back(t[i]);
    }
    #ifdef PRINT_WORDS
    int ddd=0;
    for (auto itt: v){
        printf("%d)#", ddd);
        for(auto it : itt)
            printf("%s# ", &it[0]);
        printf("\n");
        ++ddd;
    }
    #endif
    return 0;
} 

void cd_f(string* t, int n){
    if (n==1){char home[] = "HOME"; chdir(getenv(home)); return;}
    if (n==2){if (chdir(&t[1][0])<0) perror("");return;}
    fprintf(stderr, "cd: invalid argument\n");
}
void pwd_f(string* t, int n){
        if (n==1){
        char dir[4096]; getcwd(dir, 4096);
        printf("%s\n", dir);
        return;
    }
    fprintf(stderr, "pwd: invalid argument\n");
}
void echo_f(string* t, int n){
    for(int i=1; i<n; ++i) printf("%s ", &t[i][0]);
    printf("\n");
}
void set_f(string* t, int n){
    if (n>2){fprintf(stderr, "set: invalid argument\n");return;}
    if (n<2 || t[1].empty()) return;
    bool f=false;char* val = &t[1][0], *name=val;
    for(;*val!=0;++val) if(*val=='=') {*val=0; ++val; f=true; break;}
    if(!f){fprintf(stderr, "set: invalid argument\n");return;}
    if(*val=='\"') {++val; t[1][t[1].length()-1] = 0;}
    //printf("name= %s, val = %s\n", name, val);
    if(setenv(name, val, 1)<0) perror("");
}
void run_exec(string* t, int n){
    char **args = new char*[n+1];
    for (int i=0; i<n; ++i) args[i] = &t[i][0]; args[n] = NULL;
    execvp(args[0], args); perror("");
    delete[] args;
}
void timediff(timeval tv1, timeval tv2, timeval& dtv){
    dtv.tv_sec =tv2.tv_sec -tv1.tv_sec;
    dtv.tv_usec=tv2.tv_usec-tv1.tv_usec;
    if(dtv.tv_usec<0) {--dtv.tv_sec; dtv.tv_usec+=1000000;}
}
void timeprint(timeval dtv, rusage buf){
    printf("real\t%ldm%01ld,%03lds\nuser\t%ldm%01ld,%03lds\nsys\t%ldm%01ld,%03lds\n", dtv.tv_sec/60, dtv.tv_sec%60, dtv.tv_usec/1000,
     buf.ru_utime.tv_sec/60, buf.ru_utime.tv_sec%60, buf.ru_utime.tv_usec/1000,
     buf.ru_stime.tv_sec/60, buf.ru_stime.tv_sec%60, buf.ru_stime.tv_usec/1000);
}
void run_process(string*, int);
void time_f(string* t, int n){
    timeval tv1, tv2, dtv;
    struct timezone tz;
    gettimeofday(&tv1, &tz);
    pid_t pid = fork();
    if (pid == 0){++t; --n; run_process(t, n); exit(0);}
    else{
        rusage buf;
        waitpid(pid, NULL, WUNTRACED);
        gettimeofday(&tv2, &tz);
        if (getrusage(RUSAGE_CHILDREN, &buf)<0) perror("getrusage");
        timediff(tv1, tv2, dtv); timeprint(dtv, buf);
    }
}

void run_process(string* t, int n){
    if(n==0) return;
    #ifdef RUN_PROCESSES
    auto it = Microsha_functions.find(t[0]);
    if (it == Microsha_functions.end()) run_exec(&t[0], n);
    else it->second(t, n);
    #endif
}
void run4(vector<vector<string>>& l, string& input_filename, string& output_filename,
 bool input_flag, bool output_flag){
    int n = l.size();
    vector<string> *t = &l[0];
    if(n==0) return;
    int savein = dup(0), saveout = dup(1);
    int input = 0, output = 1;
    bool input_opened = false, output_opened = false;
    if (input_flag){
        if ((input = open(&input_filename[0], O_RDONLY))<0) perror("");
        else{dup2(input, 0); input_opened = true; close(input);}
    }
    if (output_flag){
        if ((output = open(&output_filename[0], O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH))<0) perror("");
        else{ dup2(output, 1); close(output); output_opened = true;}
    }
    bool not_run = false;
    if (n==1 &&!t[0].empty()){
        if (strcmp(&t[0][0][0], "cd")==0){
            cd_f(&t[0][0], t[0].size()); not_run = true;
        }else if (strcmp(&t[0][0][0], "set")==0){
            set_f(&t[0][0], t[0].size()); not_run = true;
        }
    }
    if (!not_run){
        int *fd = new int[(n+1)<<1];
        for (int i=1; i<n; ++i) pipe(fd+(i<<1));
        int input = 0, output = 1;
        fd[0] = dup(0); fd[1] = 0; //imaginary pipe
        fd[n<<1] = 1; fd[(n<<1)|1] = dup(1); //imaginary pipe
        int i=0; vector<pid_t> pids; pid_t pid;
        #ifdef PROCESS_DEBUG
        for (int i=0; i<n+1; ++i)
            printf("%d) in %d, out %d\n", i, fd[i<<1], fd[(i<<1)|1]);
        #endif
        for(;i<n;++i){
            pid = fork();
            if (pid==0){
                input = fd[i<<1]; output = fd[((i+1)<<1)|1];
                close(fd[(i<<1)|1]);close(fd[(i+1)<<1]);
                dup2(input, 0);dup2(output, 1);
                close(input);close(output);
                break;
            }
            else pids.push_back(pid);
        }
        delete[] fd;
        #ifdef PROCESS_DEBUG
        fprintf(stderr, "Created %d, in is %d, out is %d, me %d, p %d, ch %d\n", i, input, output, getpid(), getppid(),  pid);
        #endif
        #ifdef PIPE_DEBUG
        if (i==0) {
            write(1, "Hello\n", 6);
            fprintf(stderr, "I'm %d, end io\n", i);
        } else if (i!=n){
            char str[4096];
            int l = read(0, str, 4096);
            fprintf(stderr, "I'm %d, read %d sym: %s", i, l, str);
            write(1, str, l);
            fprintf(stderr, "I'm %d, end io\n", i);
        }
        #endif
        //body
        if(i!=n) {
            run_process(&t[0][0], t[0].size());
            exit(0);
        }
        //END_body
        #ifdef PROCESS_DEBUG
        printf("everithing is ok1\n");
        #endif
        for (auto it : pids)
            waitpid(it, NULL, WUNTRACED);
        #ifdef PROCESS_DEBUG
        printf("everithing is ok2\n");
        #endif
    }
    dup2(savein, 0); dup2(saveout, 1);
    close(savein); close(saveout);
}

int main()
{
    {
        string f;
        f="cd"; f.push_back(0);
        Microsha_functions.insert(pair<string, void (*)(string*, int)>(f, cd_f));
        f = "pwd"; f.push_back(0);
        Microsha_functions.insert(pair<string, void (*)(string*, int)>(f, pwd_f));
        f = "time"; f.push_back(0);
        Microsha_functions.insert(pair<string, void (*)(string*, int)>(f, time_f));
        f = "echo"; f.push_back(0);
        Microsha_functions.insert(pair<string, void (*)(string*, int)>(f, echo_f));
        f = "set"; f.push_back(0);
        Microsha_functions.insert(pair<string, void (*)(string*, int)>(f, set_f));
    }
    bool sudoflag = false;
    if (getuid()==0){
        #ifdef ROOT_DEBUG
        cout<<"root\n";
        #endif
        sudoflag = true;
    }
    for(;!feof(stdin);){
        greeting(sudoflag);
        string s;
        get_string(s);
        env_f(s);
        vector<string> t;
        string_to_words1(s, t);
        string input_filename, output_filename;
        bool input_flag, output_flag, time_flag;
        vector<vector<string>> v;
        if(parce(t, v, input_filename, output_filename, input_flag, output_flag, time_flag)<0){
            fprintf(stderr, "<> mistake\n");
            continue;
        }
        if (time_flag){
            timeval tv1, tv2, dtv;
            struct timezone tz;
            gettimeofday(&tv1, &tz);
            pid_t pid = fork();
            if (pid == 0){run4(v, input_filename, output_filename, input_flag, output_flag);exit(0);}
            else{
                rusage buf; waitpid(pid, NULL, WUNTRACED);
                gettimeofday(&tv2, &tz);
                if (getrusage(RUSAGE_CHILDREN, &buf)<0) perror("getrusage");
                timediff(tv1, tv2, dtv); timeprint(dtv, buf);
            }
        }else run4(v, input_filename, output_filename, input_flag, output_flag);
    }
    printf("\n");
}
