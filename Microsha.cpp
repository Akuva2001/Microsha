#include <unistd.h>
#include <stdio.h>
#include <dirent.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <stdlib.h>
#include <iostream>
#include <vector>
#include <string>
#include <time.h>
#include <cstring>
#include <sys/dir.h>
#include <fcntl.h>
#include <dirent.h>
#include <map>
#include <sys/resource.h>
#include <sys/time.h>
using namespace std;
//COLORS:
#define GREEN_BOLD   "\x1b[1;32m"
#define COLOR_RESET   "\x1b[0m"

//DEBUG:
//#define ROOT_DEBUG
//#define PRINT_ENV
//#define ENV_F_DEBUG
//#define PRINT_WORDS
//#define PROCESS_DEBUG
//#define PIPE_DEBUG

//RUN
#define RUN_PROCESSES

map<string, void (*)(string*, int)> Microsha_functions;

void greeting(bool sudoflag){
    char dir[4096];
    getcwd(dir, 4096);
    sudoflag?printf(GREEN_BOLD "%s!" COLOR_RESET, dir):printf(GREEN_BOLD "%s>" COLOR_RESET, dir);
}

void get_string(string &s){
    for(char c = getchar();!feof(stdin) && c!='\n';s.push_back(c), c = getchar());
}


/*for(int i=0; i<256; ++i){
    if (i>='a' && i<='z' || i>='A' && i<='Z' || i>='0' && i<='9' || i=='_')
        cout<<"1, ";
    else cout<<"0, ";
}*/
const int ENV_NAME[256] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,//generated by code above
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};

void env_f(string& s){
    #ifdef ENV_F_DEBUG
    cout<<"env_f string: "<<s<<'\n';
    #endif
    bool f = false;
    for(int i=0; i<s.size(); ++i){
        if (s[i]=='\"'){f = !f; continue;}
        if (f) continue;
        if(s[i]=='$'){
            int save = i; ++i;
            string w;
            bool t=false;
            if(s[i]=='('){ ++i; t=true;}
            for (; i<s.size() && ENV_NAME[s[i]]==1; ++i)
                w.push_back(s[i]);
            w.push_back(0);
            char symbol = 0, *p = getenv(&w[0]); 
            if (p==NULL) p=&symbol;
            if (t) ++i;
            s.erase(save, i-save);
            const int len=strlen(p);
            s.insert(save, p); i = save+len-1;
        }
    }
}
void expand_links(string& w, vector<string>& t){//expand \* and \?
    bool f=true;
    for (auto it:w) if (it=='*' || it=='?') f=false;
    if (f){ t.push_back(w); return;}
    t.push_back(w);//dummy
}
void string_to_words1(string& s, vector<string>& t){
    s.push_back(0);
    bool f=false;
    string w;
    for(int i=0; s[i]!=0; ++i){
        if (s[i]=='\"'){
            f = !f;
            w.push_back(s[i]);
            continue;
        }
        if (f) {w.push_back(s[i]); continue;}
        if (s[i]=='\t' || s[i]==' ' || s[i]=='\n'){
            if (!w.empty()) {w.push_back(0); expand_links(w, t);}
            w.clear();
            continue;
        }
        w.push_back(s[i]);
    }
    if (!w.empty()) {w.push_back(0); expand_links(w, t);}
}
int parce(vector<string>& t, vector<vector<string>>& v, string& input_filename, string& output_filename,
 bool& input_flag, bool& output_flag, bool& time_flag){
    int j=0;
    time_flag = input_flag = output_flag = false;
    int i=0;
    if (!t.empty() && !t[0].empty() && strcmp(&t[0][0], "time") == 0) {++i; time_flag = true;}
    vector<string> p;
    v.push_back(p);
    bool conveyer_flag=false;
    for (int n=t.size(); i<n; ++i){
        if (strcmp(&t[i][0], "|") == 0) {
            if (output_flag) return -1;
            ++j; v.push_back(p); conveyer_flag = true; continue;
        }
        if (strcmp(&t[i][0], ">") == 0) {
            if (!output_flag && i!=n-1){
                ++i;
                output_filename = t[i];
                output_flag = true;
                continue;
            } return -1;
        }
        if (strcmp(&t[i][0], "<") == 0) {
            if (!conveyer_flag && !output_flag && !input_flag && i!=n-1){
                ++i;
                input_filename = t[i];
                input_flag = true;
                continue;
            } return -1;
        }
        v[j].push_back(t[i]);
    }
    #ifdef PRINT_WORDS
    int ddd=0;
    for (auto itt: v){
        printf("%d)#", ddd);
        for(auto it : itt)
            printf("%s# ", &it[0]);
        printf("\n");
        ++ddd;
    }
    #endif
    return 0;
} 

void cd_f(string* t, int n){
    //fprintf(stderr, "I'm cd_f\n");
    if (n==1){
        char home[] = "HOME";
        chdir(getenv(home));
        return;
    }
    if (n==2){
        if (chdir(&t[1][0])<0) perror("");
        return;
    }
    fprintf(stderr, "cd: invalid argument\n");
}
void pwd_f(string* t, int n){
        if (n==1){
        char dir[4096];
        getcwd(dir, 4096);
        printf("%s\n", dir);
        return;
    }
    fprintf(stderr, "pwd: invalid argument\n");
}
void echo_f(string* t, int n){
    for(int i=1; i<n; ++i)
        printf("%s ", &t[i][0]);
    printf("\n");
}
void set_f(string* t, int n){
    if (n>2){
        fprintf(stderr, "set: invalid argument\n");
        return;
    }
    if (n<2 || t[1].empty()) return;
    bool f=false;
    char* val = &t[1][0], *name=val;
    for(;*val!=0;++val)
        if(*val=='=') {*val=0; ++val; f=true; break;}
    if(!f){
        fprintf(stderr, "set: invalid argument\n");
        return;
    }
    if(*val=='\"') {++val; t[1][t[1].length()-1] = 0;}
    //printf("name= %s, val = %s\n", name, val);
    if(setenv(name, val, 1)<0) perror("");
}
void run_exec(string* t, int n){
    char **args = new char*[n+1];
    for (int i=0; i<n; ++i)
        args[i] = &t[i][0];
    args[n] = NULL;
    execvp(args[0], args);
    perror("");
    delete[] args;
}
void timediff(timeval tv1, timeval tv2, timeval& dtv){
    dtv.tv_sec= tv2.tv_sec -tv1.tv_sec;
    dtv.tv_usec=tv2.tv_usec-tv1.tv_usec;
    if(dtv.tv_usec<0) {--dtv.tv_sec; dtv.tv_usec+=1000000; }
}
void timeprint(timeval dtv, rusage buf){
    printf("real\t%ldm%01ld,%03lds\nuser\t%ldm%01ld,%03lds\nsys\t%ldm%01ld,%03lds\n", dtv.tv_sec/60, dtv.tv_sec%60, dtv.tv_usec/1000,
     buf.ru_utime.tv_sec/60, buf.ru_utime.tv_sec%60, buf.ru_utime.tv_usec/1000,
     buf.ru_stime.tv_sec/60, buf.ru_stime.tv_sec%60, buf.ru_stime.tv_usec/1000);
}
void run_process(string*, int);
void time_f(string* t, int n){
    timeval tv1, tv2, dtv;
    struct timezone tz;
    gettimeofday(&tv1, &tz);
    pid_t pid = fork();
    if (pid == 0){
        ++t; --n;
        run_process(t, n);
        exit(0);
    }
    else{
        waitpid(pid, NULL, WUNTRACED);
        gettimeofday(&tv2, &tz);
        rusage buf;
        if (getrusage(RUSAGE_CHILDREN, &buf)<0) perror("getrusage");
        timediff(tv1, tv2, dtv);
        timeprint(dtv, buf);
    }
}

void run_process(string* t, int n){
    if(n==0) return;
    #ifdef RUN_PROCESSES
    auto it = Microsha_functions.find(t[0]);
    if (it == Microsha_functions.end()) run_exec(&t[0], n);
    else it->second(t, n);
    #endif
}

void run4(vector<vector<string>>& l, string& input_filename, string& output_filename,
 bool input_flag, bool output_flag){
    int n = l.size();
    vector<string> *t = &l[0];
    if(n==0) return;
    int savein = dup(0), saveout = dup(1);
    int input = 0, output = 1;
    bool input_opened = false, output_opened = false;
    if (input_flag){
        if ((input = open(&input_filename[0], O_RDONLY))<0) perror("");
        else{dup2(input, 0); input_opened = true; close(input);}
    }
    if (output_flag){
        if ((output = open(&output_filename[0], O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH))<0) perror("");
        else{ dup2(output, 1); close(output); output_opened = true;}
    }
    bool not_run = false;
    if (n==1 &&!t[0].empty()){
        if (strcmp(&t[0][0][0], "cd")==0){
            cd_f(&t[0][0], t[0].size()); not_run = true;
        }else if (strcmp(&t[0][0][0], "set")==0){
            set_f(&t[0][0], t[0].size()); not_run = true;
        }
    }
    if (!not_run){
        int *fd = new int[(n+1)<<1];
        for (int i=1; i<n; ++i)
            pipe(fd+(i<<1));
        int input = 0, output = 1;
        fd[0] = dup(0); fd[1] = 0; //imaginary pipe
        fd[n<<1] = 1; fd[(n<<1)|1] = dup(1); //imaginary pipe
        int i=0;
        vector<pid_t> pids;
        pid_t pid;
        #ifdef PROCESS_DEBUG
        for (int i=0; i<n+1; ++i)
            printf("%d) in %d, out %d\n", i, fd[i<<1], fd[(i<<1)|1]);
        #endif
        for(;i<n;++i){
            pid = fork();
            if (pid==0){
                input = fd[i<<1];
                output = fd[((i+1)<<1)|1];
                close(fd[(i<<1)|1]);
                close(fd[(i+1)<<1]);
                dup2(input, 0);
                dup2(output, 1);
                close(input);
                close(output);
                break;
            }
            else{
                //if (i==n-1){ ++i; break;}
                pids.push_back(pid);
            }
        }
        delete[] fd;
        #ifdef PROCESS_DEBUG
        fprintf(stderr, "Created %d, in is %d, out is %d, me %d, p %d, ch %d\n", i, input, output, getpid(), getppid(),  pid);
        #endif
        #ifdef PIPE_DEBUG
        if (i==0) {
            write(1, "Hello\n", 6);
            fprintf(stderr, "I'm %d, end io\n", i);
        }
        else if (i!=n){
            char str[4096];
            int l = read(0, str, 4096);
            fprintf(stderr, "I'm %d, read %d sym: %s", i, l, str);
            write(1, str, l);
            fprintf(stderr, "I'm %d, end io\n", i);
        }
        #endif
        //body
        if(i!=n) {
            run_process(&t[0][0], t[0].size());
            exit(0);
        }
        //END_body
        #ifdef PROCESS_DEBUG
        printf("everithing is ok1\n");
        #endif
        for (auto it : pids)
            waitpid(it, NULL, WUNTRACED);
        #ifdef PROCESS_DEBUG
        printf("everithing is ok2\n");
        #endif
    }
    dup2(savein, 0); dup2(saveout, 1);
    close(savein); close(saveout);
}

int main()
{
    {
        string f;
        f="cd"; f.push_back(0);
        Microsha_functions.insert(pair<string, void (*)(string*, int)>(f, cd_f));
        f = "pwd"; f.push_back(0);
        Microsha_functions.insert(pair<string, void (*)(string*, int)>(f, pwd_f));
        f = "time"; f.push_back(0);
        Microsha_functions.insert(pair<string, void (*)(string*, int)>(f, time_f));
        f = "echo"; f.push_back(0);
        Microsha_functions.insert(pair<string, void (*)(string*, int)>(f, echo_f));
        f = "set"; f.push_back(0);
        Microsha_functions.insert(pair<string, void (*)(string*, int)>(f, set_f));
    }
    bool sudoflag = false;
    if (getuid()==0){
        #ifdef ROOT_DEBUG
        cout<<"root\n";
        #endif
        sudoflag = true;
    }
    for(;!feof(stdin);){
        greeting(sudoflag);
        string s;
        get_string(s);
        env_f(s);
        vector<string> t;
        string_to_words1(s, t);
        string input_filename, output_filename;
        bool input_flag, output_flag, time_flag;
        vector<vector<string>> v;
        if(parce(t, v, input_filename, output_filename, input_flag, output_flag, time_flag)<0){
            fprintf(stderr, "<> mistake\n");
            continue;
        }
        if (time_flag){
            timeval tv1, tv2, dtv;
            struct timezone tz;
            gettimeofday(&tv1, &tz);
            pid_t pid = fork();
            if (pid == 0){
                run4(v, input_filename, output_filename, input_flag, output_flag);
                exit(0);
            }
            else{
                waitpid(pid, NULL, WUNTRACED);
                gettimeofday(&tv2, &tz);
                rusage buf;
                if (getrusage(RUSAGE_CHILDREN, &buf)<0) perror("getrusage");
                timediff(tv1, tv2, dtv);
                timeprint(dtv, buf);
            }
        }else
            run4(v, input_filename, output_filename, input_flag, output_flag);
    }
    printf("\n");
}
