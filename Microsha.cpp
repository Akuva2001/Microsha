#include <unistd.h>
#include <stdio.h>
#include <dirent.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <stdlib.h>
#include <iostream>
#include <vector>
#include <string>
#include <time.h>
#include <cstring>
#include <sys/dir.h>
#include <map>
using namespace std;
//COLORS:
#define GREEN_BOLD   "\x1b[1;32m"
#define COLOR_RESET   "\x1b[0m"

//DEBUG:
//#define ROOT_DEBUG
//#define PRINT_ENV
//#define ENV_F_DEBUG
//#define PRINT_WORDS
//#define PROCESS_DEBUG
//#define PIPE_DEBUG

//RUN
#define RUN_PROCESSES

map<string, void (*)(vector<string>&)> Microsha_functions;

void greeting(bool sudoflag){
    char dir[4096];
    getcwd(dir, 4096);
    sudoflag?printf(GREEN_BOLD "%s!" COLOR_RESET, dir):printf(GREEN_BOLD "%s>" COLOR_RESET, dir);
}

void get_string(string &s){
    for(char c = getchar();!feof(stdin) && c!='\n';s.push_back(c), c = getchar());
}


/*for(int i=0; i<256; ++i){
    if (i>='a' && i<='z' || i>='A' && i<='Z' || i>='0' && i<='9' || i=='_')
        cout<<"1, ";
    else cout<<"0, ";
}*/
const int ENV_NAME[256] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,//generated by code above
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};

void env_f(string& s){
    #ifdef ENV_F_DEBUG
    cout<<"env_f string: "<<s<<'\n';
    #endif
    bool f = false;
    for(int i=0; i<s.size(); ++i){
        if (s[i]=='\"'){
            f = !f;
            continue;
        }
        if (f) continue;
        if(s[i]=='$'){
            int save = i;
            ++i;
            string w;
            bool t=false;
            if(s[i]=='('){
                ++i;
                t=true;
            }
            for (; i<s.size() && ENV_NAME[s[i]]==1; ++i)
                w.push_back(s[i]);
            w.push_back(0);
            char* p = getenv(&w[0]);
            if (p==NULL){
                fprintf(stderr, "no env\n");
                continue;
            }
            if (t) ++i;
            s.erase(save, i-save);
            #ifdef ENV_F_DEBUG
            printf("i-save = %d\n", i-save);
            #endif
            const int len=strlen(p);
            s.insert(save, p);
            i = save+len-1;
        }
    }
}


void expand_links(string& w, vector<string>& t){//expand \* and \?
    bool f=true;
    for (auto it:w)
        if (it=='*' || it=='?') f=false;
    if (f){
        t.push_back(w);
        return;
    }
    t.push_back(w);//dummy
}

void string_to_words(string& s, vector<vector<string>>& t){
    s.push_back(0);
    bool f=false;
    int j=0;
    vector<string> b;
    t.push_back(b);
    string w;
    for(int i=0; s[i]!=0; ++i){
        if (s[i]=='\"'){
            f = !f;
            w.push_back(s[i]);
            continue;
        }
        if (f){
            w.push_back(s[i]);
            continue;
        }
        if (s[i]=='\t' || s[i]==' ' || s[i]=='\n'){
            if (!w.empty()){
                w.push_back(0);
                if (strcmp("|", &w[0])==0){
                    ++j;
                    t.push_back(b);
                } else expand_links(w, t[j]);
            }
            w.clear();
            continue;
        }
        w.push_back(s[i]);
    }
    if (!w.empty()){
        w.push_back(0);
        if (strcmp("|", &w[0])==0){
            ++j;
            t.push_back(b);
        } else expand_links(w, t[j]);
    }
    #ifdef PRINT_WORDS
    int ddd=0;
    for (auto itt: t){
        printf("%d)#", ddd);
        for(auto it : itt)
            printf("%s# ", &it[0]);
        printf("\n");
        ++ddd;
    }
    #endif
}

void cd_f(vector<string>& t){
    //fprintf(stderr, "I'm cd_f\n");
    if (t.size()==1){
        char home[] = "HOME";
        chdir(getenv(home));
        return;
    }
    if (t.size()==2){
        if (chdir(&t[1][0])<0) perror("");
        return;
    }
    fprintf(stderr, "cd: invalid argument\n");
}
void pwd_f(vector<string>& t){
        if (t.size()==1){
        char dir[4096];
        getcwd(dir, 4096);
        printf("%s\n", dir);
        return;
    }
    fprintf(stderr, "pwd: invalid argument\n");
}
void time_f(vector<string>& t){

}
void echo_f(vector<string>& t){

}
void set_f(vector<string>& t){

}
void run_exec(vector<string>& t){
    const int n = t.size();
    char **args = new char*[n+1];
    for (int i=0; i<n; ++i)
        args[i] = &t[i][0];
    args[n] = NULL;
    execvp(args[0], args);
    perror("");
    delete[] args;
}

void run3(vector<vector<string>>& l){
    int n = l.size();
    vector<string> *t = &l[0];
    for(;n>0 && t[0].size()==0;--n, ++t);
    if(n==0) return;
    if (strcmp(&t[0][0][0], "cd")==0){
        cd_f(t[0]);--n; ++t;
    }
    if(n==0) return;

    int *fd = new int[(n+1)<<1];
    for (int i=1; i<n; ++i)
        pipe(fd+(i<<1));
    int input = 0, output = 1;
    fd[0] = dup(0); fd[1] = 0; //imaginary pipe
    fd[n<<1] = 1; fd[(n<<1)|1] = dup(1); //imaginary pipe
    int i=0;
    vector<pid_t> pids;
    pid_t pid;
    #ifdef PROCESS_DEBUG
    for (int i=0; i<n+1; ++i)
        printf("%d) in %d, out %d\n", i, fd[i<<1], fd[(i<<1)|1]);
    #endif
    for(;i<n;++i){
        pid = fork();
        if (pid==0){
            input = fd[i<<1];
            output = fd[((i+1)<<1)|1];
            close(fd[(i<<1)|1]);
            close(fd[(i+1)<<1]);
            dup2(input, 0);
            dup2(output, 1);
            close(input);
            close(output);
            break;
        }
        else{
            //if (i==n-1){ ++i; break;}
            pids.push_back(pid);
        }
    }
    delete[] fd;
    #ifdef PROCESS_DEBUG
    fprintf(stderr, "Created %d, in is %d, out is %d, me %d, p %d, ch %d\n", i, input, output, getpid(), getppid(),  pid);
    #endif
    #ifdef PIPE_DEBUG
    if (i==0) {
        write(1, "Hello\n", 6);
        fprintf(stderr, "I'm %d, end io\n", i);
    }
    else if (i!=n){
        char str[4096];
        int l = read(0, str, 4096);
        fprintf(stderr, "I'm %d, read %d sym: %s", i, l, str);
        write(1, str, l);
        fprintf(stderr, "I'm %d, end io\n", i);
    }
    #endif
    //body
    if(i!=n) {
        if(t[i].size()!=0){
            #ifdef RUN_PROCESSES
            auto it = Microsha_functions.find(t[i][0]);
            if (it == Microsha_functions.end()) run_exec(t[i]);
            else it->second(t[i]);
            #endif
        }
        exit(0);
    }
    //END_body
    #ifdef PROCESS_DEBUG
    printf("everithing is ok1\n");
    #endif
    for (auto it : pids)
        waitpid(it, NULL, WUNTRACED);
    #ifdef PROCESS_DEBUG
    printf("everithing is ok2\n");
    #endif
}

int main()
{
    {
        string f;
        f="cd"; f.push_back(0);
        Microsha_functions.insert(pair<string, void (*)(vector<string>&)>(f, cd_f));
        f = "pwd"; f.push_back(0);
        Microsha_functions.insert(pair<string, void (*)(vector<string>&)>(f, pwd_f));
        f = "time"; f.push_back(0);
        Microsha_functions.insert(pair<string, void (*)(vector<string>&)>(f, time_f));
        f = "echo"; f.push_back(0);
        Microsha_functions.insert(pair<string, void (*)(vector<string>&)>(f, echo_f));
        f = "set"; f.push_back(0);
        Microsha_functions.insert(pair<string, void (*)(vector<string>&)>(f, set_f));
    }
    bool sudoflag = false;
    if (getuid()==0){
        #ifdef ROOT_DEBUG
        cout<<"root\n";
        #endif
        sudoflag = true;
    }
    for(;!feof(stdin);){
        greeting(sudoflag);
        string s;
        get_string(s);
        env_f(s);
        //cout<<s<<"\n";
        vector<vector<string>> t;
        string_to_words(s, t);
        run3(t);
    }
    printf("\n");
}
